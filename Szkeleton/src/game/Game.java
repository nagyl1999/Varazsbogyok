package game;

/*

  Generated by StarUML(tm) Java Add-In

  @ Project : Varazsbogyok
  @ File Name : game.Game.java
  @ Date : 2022. 03. 23.
  @ Author : varazsbogyok

*/

import entity.Bot;
import entity.Player;
import entity.Virologist;
import graphics.VarazsbogyokFrame;

import java.awt.Color;
import java.io.Serializable;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Random;
import java.util.Random;
/**
 * Játék objektum, felelőssége a játék elindítása, időzitő beállítása. A pálya generálása.
 */
public final class Game implements Serializable {
    /**
     * JÃtéktér
     */
    public static Map map;
    /**
     * A játékban a pályaelemek száma
     */
    public static int tileCount = 10;
    /**
     * Minimum mezők
     */
    public static int minTileCount = 10;
    /**
     * A játékban a botok száma
     */
    public static int botCount = 3;
    /**
     * Minimum botok
     */
    public static int minBotCount = 3;
    /**
     * A játékban az egyes pályaelemek maximális szomszédjaa
     */
    public static int maxNeighbours = 4;
    /**
     * A játékban az idÅőzítő
     */
    public static Timer timer;
    /**
     * Aktív virológus
     */
    public static Virologist activeVirologist;
    
    public static int minDistance = 20;
    
    public static int linethickness = 5;
    

    /**
     * Konstruktor
     */
    public Game() {
    }

    /**
     * pálya és timer létrehozása.
     */
    public static void newGame() {
        map = new Map();
        generateRandomMap();
        timer = Timer.getInstance();
        //timer.tick();
    }
    
    public static void randomTilePoints() {
    	//TODO
        int x, y;
    	ArrayList<Vec2> exceptions = new ArrayList<>();
        for (int i =0; i< tileCount;i++) {
            do{
                double dx = VarazsbogyokFrame.getInstance().getSize().getHeight();
                double dy = VarazsbogyokFrame.getInstance().getSize().getWidth();
                x = randInt(0, (int)dx, 2);
                y = randInt(0, (int)dy, 2);
            }
            while(equals(exceptions, new Vec2(x, y)) || accept(new Vec2(x,y)));
            exceptions.add(new Vec2(x,y));
            Tile t = randomTile();
            t.setX(x);
            t.setY(y);
            map.addTile(t);
        }
    }

    public static boolean equals(ArrayList<Vec2> e, Vec2 a) {
        for (Vec2 v : e)
            if (v.getX() == a.getX() && v.getY() == a.getY())
                return true;
        return false;
    }
    
    public static boolean accept(Vec2 a){
        for(int i = 0;i< map.getTiles().size();i++){
            if(a.getDistance(new Vec2(map.getTiles().get(i).getX(),map.getTiles().get(i).getY())) <minDistance) return true;
        }
        return false;
    }
    public static int randInt(int first, int last, int step) {
    	//TODO
        int nsteps = (last+1-first) / step;
        return first + step*(int)(nsteps*Math.random());
    }
    
    public static void generateRandomMap() {
    	//TODO
    	randomTilePoints();
    	for(int x = 0; x < 500;x++) {
    		for(int y =0; y < 800;y++ ) {
    			double distance = 800*500;
    			int choosen = 0;
    			int choosen2 = 0;
    			for(int i = 0; i < tileCount;i++) {
    				double temp = new Vec2(x, y).getDistance(new Vec2(map.getTiles().get(i).getX(),map.getTiles().get(i).getY()));
                    if(temp < distance){
                        distance = temp;
                        choosen = i;
                    }
    			}
                distance = 800*500;
                for(int i = 0; i < tileCount;i++) {
                    if (i == choosen)
                        continue;
                    double temp = new Vec2(x, y).getDistance(new Vec2(map.getTiles().get(i).getX(),map.getTiles().get(i).getY()));
                    if(temp < distance){
                        distance = temp;
                        choosen2 = i;
                    }
                }
    			
    			double t1 = new Vec2(x,y).getDistance( new Vec2(map.getTiles().get(choosen).getX(),map.getTiles().get(choosen).getY() ));
                double t2 = new Vec2(x,y).getDistance( new Vec2(map.getTiles().get(choosen2).getX(),map.getTiles().get(choosen2).getY() ));

                if(Math.abs(t1-t2)>linethickness) map.getTiles().get(choosen).getPolygon().addPoint(x, y);
    		}
    	}
    }

    /**
     * Pályagenerálás, beállít egy véletenszerű pályát.
     */
    public static void generateRandomMap2() {
        ArrayList<Integer> neighbours = new ArrayList<Integer>();
        for (int i = 0; i < tileCount; i++) map.addTile(randomTile());
        for (int i = 0; i < tileCount; i++) {
            neighbours.clear();
            //itt felépitjuk az esetleges szomszédok listáját, kivéve a soron lévő elemet
            for (int j = 0; j < tileCount; j++) if (i != j) neighbours.add(j);
            /* Itt fogjuk a szomszédokat beállitani, egy pályaelemnek legfeljebb
             * maxNeighbours szomszéja lehet, ezutÃ¡n hozzÃ¡adunk a neighbours listÃ¡bol egyet,
             * miutÃ¡n hozzÃ¡adtuk kivesszÃ¼k a neighbours listÃ¡bol az elemet, igy a listÃ¡ban
             * csak olyan elemek maradnak amik mÃ©g nem szomszÃ©dosak az adott pÃ¡lyaelemmek*/
            Random r = new Random();
            for (int j = 0; j < r.nextInt(maxNeighbours); j++) {
                int n = r.nextInt(tileCount - j - 1);
                map.getTiles().get(i).addNeighbour(map.getTiles().get(n));
                neighbours.remove(n);
            }
        }
        //játékos létrehozása és hozzáadaása a léptethető osztályhoz
        map.getTiles().get(0).addVirologist(new Player());
        timer.addSteppable(map.getTiles().get(0).getVirologist().get(0));
        //botok létrehozása és hozzáadása a léptethető dolgokhoz
        for (int i = 1; i <= botCount; i++) {
            map.getTiles().get(i).addVirologist(new Bot());
            timer.addSteppable(map.getTiles().get(i).getVirologist().get(0));
        }
    }

    /**
     * Játékból való kilépés
     */
    public static void exitGame() {
        System.out.println("A jÃ¡tÃ©knak vÃ©ge :/");

    }

    /**
     * Egy virológus megnyerte a játékot
     */
    public static void winGame(Virologist v) {
        System.out.println("A játékot " + v.toString() + " nyerte");
    }

    /**
     * Egy véletlenszeru pályaelemet generál
     */
    public static Tile randomTile() {
        Random r = new Random();
        int n = r.nextInt(4);
        switch (n) {
            case 0:
            	SafeLaboratory safelaboratory = new SafeLaboratory();
            	safelaboratory.setColor(Color.red);
                return  safelaboratory;
            case 1:
            	Safehouse safehouse = new Safehouse();
            	safehouse.setColor(Color.blue);
                return safehouse;
            case 2:
            	Storage storage = new Storage();
            	storage.setColor(Color.yellow);
                return  storage;
            case 3:
            	BearLaboratory bearlaboratory = new BearLaboratory();
                bearlaboratory.setColor(Color.red);
            	return bearlaboratory;
            default:
            	Town town = new Town();
            	town.setColor(Color.green);
                return town;
        }
    }
}